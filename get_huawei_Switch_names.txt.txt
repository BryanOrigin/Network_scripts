SNMP Reachability Scanner ‚Äî Documentation
=========================================

Purpose:
--------
This Python 3 script scans a list of IP addresses and subnets to check:

1. Whether each host is reachable via ping
2. Whether SNMP responds with a valid system name (sysName)

It generates two output files:
- reachable_switches.txt ‚Üí for devices that respond to ping and SNMP
- unreachable_switches.txt ‚Üí for devices that do not respond to ping

SNMP sysName is retrieved using OID: 1.3.6.1.2.1.1.5.0

Usage Notes:
------------
- You can specify any mix of subnets (e.g. 10.197.0.0/25) and individual IPs (e.g. 10.197.0.10/32) in the `targets` list.
- The script automatically expands subnets into individual host IPs.
- SNMP community string is configurable via the `community` variable.

Setup Instructions (Linux):
---------------------------
Run these commands on a new Linux machine before executing the script:

1. Install Python 3:
   sudo apt update
   sudo apt install python3

2. Install SNMP tools:
   sudo apt install snmp

3. Install ping utility (if missing):
   sudo apt install iputils-ping

4. Create output folder:
   mkdir -p textfolder

5. Run the script:
   python3 snmp_reachability.py

Quick one-liner setup:
----------------------
sudo apt update && sudo apt install -y python3 snmp iputils-ping && mkdir -p textfolder

Source Code:
------------
Save the following as snmp_reachability.py

[START OF SCRIPT]

#!/usr/bin/env python3

import subprocess
import ipaddress
import platform

def ping_host(host):
    """Ping a host to check if it‚Äôs alive"""
    param = "-n" if platform.system().lower() == "windows" else "-c"
    try:
        result = subprocess.run(
            ["ping", param, "1", host],
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
        return result.returncode == 0
    except Exception:
        return False

def get_system_name(host, community="public"):
    """Fetch system name via SNMP"""
    try:
        cmd = ["snmpget", "-v2c", "-c", community, host, "1.3.6.1.2.1.1.5.0"]
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=5)

        if result.returncode == 0:
            output = result.stdout.strip()
            if "STRING:" in output:
                return output.split("STRING:")[1].strip().strip('"').strip("'")
            else:
                return output
        else:
            return None
    except Exception:
        return None

def expand_targets(targets):
    """Expand list of CIDRs and /32 IPs into host IPs"""
    all_hosts = []
    for target in targets:
        try:
            net = ipaddress.ip_network(target, strict=False)
            if net.prefixlen == 32:  # Single host (/32)
                all_hosts.append(str(net.network_address))
            else:  # Subnet
                for host in net.hosts():
                    all_hosts.append(str(host))
        except ValueError:
            print(f"‚ö†Ô∏è Skipping invalid target: {target}")
    return all_hosts

def main():
    # üîë Add your mix of subnets and /32 IPs here
    targets = [
        "10.197.0.0/25",     # whole subnet
        "10.197.0.128/26",   # smaller subnet
        "10.196.0.0/25",
        "10.196.0.128/26"    # another range
    ]

    community = "EXPL-IN-GOA"  # SNMP community string

    reachable_file = "textfolder/reachable_switches.txt"
    unreachable_file = "textfolder/unreachable_switches.txt"

    all_ips = expand_targets(targets)

    with open(reachable_file, "w") as rf, open(unreachable_file, "w") as uf:
        for ip_str in all_ips:
            print(f"Checking {ip_str}...")

            if ping_host(ip_str):
                print(f"  {ip_str} is pingable ‚úÖ")
                sys_name = get_system_name(ip_str, community)
                if sys_name:
                    line = f"{ip_str} - {sys_name}\n"
                    print(f"  SNMP OK ‚Üí {line.strip()}")
                    rf.write(line)
                    rf.flush()
                else:
                    line = f"{ip_str} - SNMP query failed\n"
                    print(f"  SNMP failed ‚ö†Ô∏è ‚Üí {ip_str}")
                    rf.write(line)
                    rf.flush()
            else:
                print(f"  {ip_str} unreachable ‚ùå")
                uf.write(f"{ip_str}\n")
                uf.flush()

    print("\n‚úÖ Scan completed. Results saved to:")
    print(f"  - {reachable_file}")
    print(f"  - {unreachable_file}")

if __name__ == "__main__":
    main()

[END OF SCRIPT]